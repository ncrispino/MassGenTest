# Example configuration demonstrating the hook framework
#
# Hooks intercept tool execution at two points:
# - PreToolUse: Before tool execution (can block, ask, or modify arguments)
# - PostToolUse: After tool execution (can inject content into results)
#
# Hooks can be registered at two levels:
# - Global (top-level `hooks:`): Apply to ALL agents
# - Per-agent (under `backend.hooks:`): Apply to specific agent only
#
# Per-agent hooks can either extend or override global hooks.
#
# NOTE: The handler paths below are examples. Replace with your own
# Python module paths (e.g., "myproject.hooks.my_hook_function").

# Global hooks - apply to all agents
hooks:
  PreToolUse:
    # Audit all tool calls with a Python callable
    - matcher: "*"
      handler: "myproject.hooks.audit_tool_calls"  # Replace with your module
      type: python
      timeout: 5

  PostToolUse:
    # Log all tool outputs
    - matcher: "*"
      handler: "myproject.hooks.log_tool_output"  # Replace with your module
      type: python

agents:
  - id: "secure_agent"
    backend:
      type: claude
      model: claude-sonnet-4-20250514

      # Per-agent hooks - extend global hooks by default
      hooks:
        PreToolUse:
          # Additional security check for this agent
          - matcher: "mcp__file_write|mcp__file_delete"
            handler: "myproject.hooks.require_file_approval"
            type: python
            fail_closed: true  # Deny if hook fails (security-critical)

  - id: "unrestricted_agent"
    backend:
      type: claude
      model: claude-sonnet-4-20250514

      # Override global hooks - only use agent-specific hooks
      hooks:
        PreToolUse:
          override: true  # Disable global PreToolUse hooks
          hooks:
            - matcher: "*"
              handler: "myproject.hooks.allow_all"
              type: python

        # PostToolUse not overridden - global hooks still apply